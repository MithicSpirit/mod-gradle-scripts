// Constants
def MIN_GRADLE_VERSION = '8.5'
def MAX_EXCLUDED_GRADLE_VERSION = '9'
def FABRIC_MOD_LOADER = 'fabric'
def NEOFORGE_MOD_LOADER = 'neoforge'
def FORGE_MOD_LOADER = 'forge'

def DEFAULT_JAVA_VERSION = '17'
def DEFAULT_MOD_LOADER = FABRIC_MOD_LOADER
def DEFAULT_MOD_AUTHOR = 'Max Henkel'
def DEFAULT_RELEASE_TYPE = 'alpha'
def DEFAULT_MINECRAFT_USER_NAME_PREFIX = 'henkelmax'

def DEFAULT_CONFIGBUILDER_VERSION = '2.0.1'
def DEFAULT_FABRIC_LOADER_VERSION = '0.15.1'
def DEFAULT_MIXIN_ANNOTATION_PROCESSOR_VERSION = '0.8.4'

// Gradle version checks
def gradle_version = VersionNumber.parse(getProject().getGradle().getGradleVersion())
// Check for min Gradle version
if (gradle_version < VersionNumber.parse(MIN_GRADLE_VERSION)) {
    throw new RuntimeException("Outdated Gradle version, please update to ${MIN_GRADLE_VERSION} or later")
}
// Check for max Gradle version
if (gradle_version >= VersionNumber.parse(MAX_EXCLUDED_GRADLE_VERSION)) {
    throw new RuntimeException("Gradle version too new, please use <${MAX_EXCLUDED_GRADLE_VERSION}")
}

// Variables
checkProperty('minecraft_version')

checkProperty('mod_id')
checkProperty('mod_version')
checkProperty('mod_display_name')

ext.java_version = getOrDefault('java_version', DEFAULT_JAVA_VERSION) as int
ext.mod_loader = getOrDefault('mod_loader', DEFAULT_MOD_LOADER)
ext.mod_authors = getOrDefault('mod_authors', [DEFAULT_MOD_AUTHOR], it -> stringToStringList(it))
ext.minecraft_user_name_prefix = getOrDefault('minecraft_user_name_prefix', DEFAULT_MINECRAFT_USER_NAME_PREFIX)
ext.use_mixins = getOrDefault('use_mixins', false, it -> it.toBoolean()) //TODO Maybe only for Forge/NeoForge, since they are included by default from Fabric
ext.included_projects = getOrDefault('included_projects', [], it -> stringToStringList(it))

ext.included_projects = included_projects.findAll {
    def p = findProject(it)
    if (p == null) {
        throw new RuntimeException("Project '${it}' does not exist")
    }
    return p != getProject()
}

ext.is_fabric = mod_loader.equalsIgnoreCase(FABRIC_MOD_LOADER)
ext.is_neoforge = mod_loader.equalsIgnoreCase(NEOFORGE_MOD_LOADER)
ext.is_forge = mod_loader.equalsIgnoreCase(FORGE_MOD_LOADER)

// Fabric specific variables
if (is_fabric) {
    ext.fabric_loader_version = getOrDefault('fabric_loader_version', DEFAULT_FABRIC_LOADER_VERSION)
    ext.included_fabric_api_modules = getOrDefault('included_fabric_api_modules', [], it -> stringToStringList(it))
    ext.import_fabric_api = getOrDefault('import_fabric_api', false, it -> it.toBoolean())
    if (import_fabric_api) {
        checkProperty('fabric_api_version')
    }
    // TODO Add access widener path to fabric.mod.json
    ext.enable_accesswideners = getOrDefault('enable_accesswideners', false, it -> it.toBoolean())
    ext.add_quilt_supported_tag = getOrDefault('add_quilt_supported_tag', true, it -> it.toBoolean())
}

// Neoforge specific variables
if (is_neoforge) {
    checkProperty('neoforge_version')
}

// Forge specific variables
if (is_forge) {
    checkProperty('forge_version')
    ext.mixin_annotation_processor_version = getOrDefault('mixin_annotation_processor_version', DEFAULT_MIXIN_ANNOTATION_PROCESSOR_VERSION)
    if (use_mixins) {
        checkProperty('mixin_connector_path')
    }
}

// Libraries
ext.enable_configbuilder = getOrDefault('enable_configbuilder', false, it -> it.toBoolean())
if (enable_configbuilder) {
    ext.configbuilder_version = getOrDefault('configbuilder_version', DEFAULT_CONFIGBUILDER_VERSION)
}

// Upload
ext.upload_release_type = getOrDefault('upload_release_type', DEFAULT_RELEASE_TYPE)
ext.upload_recommended = getOrDefault('upload_recommended', false, it -> it.toBoolean())
// CurseForge upload
ext.enable_curseforge_upload = getOrDefault('enable_curseforge_upload', true, it -> it.toBoolean())
if (enable_curseforge_upload) {
    checkPlugin('com.matthewprenger.cursegradle')
    checkProperty('curseforge_upload_id')
    ext.curseforge_upload_minecraft_version = getOrDefault('curseforge_upload_minecraft_version', minecraft_version)
    ext.curseforge_upload_optional_dependencies = getOrDefault('curseforge_upload_optional_dependencies', [], it -> stringToStringList(it))

    ext.curseforge_api_key = getOrDefault('curseforge_api_key', System.env.CURSEFORGE_API_KEY)
    if (curseforge_api_key == null || curseforge_api_key.isEmpty()) {
        throw new RuntimeException('Missing environment variable CURSEFORGE_API_KEY')
    }
}
// Modrinth upload
ext.enable_modrinth_upload = getOrDefault('enable_modrinth_upload', true, it -> it.toBoolean())
if (enable_modrinth_upload) {
    checkPlugin('com.modrinth.minotaur')
    checkProperty('modrinth_upload_id')
    ext.modrinth_upload_optional_dependencies = getOrDefault('modrinth_upload_optional_dependencies', [], it -> stringToStringList(it))
    ext.modrinth_token = getOrDefault('modrinth_token', System.env.MODRINTH_TOKEN)
    if (modrinth_token == null || modrinth_token.isEmpty()) {
        throw new RuntimeException('Missing environment variable MODRINTH_TOKEN')
    }
}
// Mod update
ext.enable_mod_update = getOrDefault('enable_mod_update', true, it -> it.toBoolean())
if (enable_mod_update) {
    ext.mod_update_api_key = getOrDefault('mod_update_api_key', System.env.MOD_UPDATE_API_KEY)
    if (mod_update_api_key == null || mod_update_api_key.isEmpty()) {
        throw new RuntimeException('Missing environment variable MOD_UPDATE_API_KEY')
    }
}

// Checking if mandatory plugins exist
if (is_fabric) {
    checkPlugin('fabric-loom')
}
if (is_neoforge) {
    // Neoforge gradle
    checkPlugin('net.neoforged.gradle.userdev')
    // Neoforge mixins
    checkPlugin('net.neoforged.gradle.mixin')
}
if (is_forge) {
    // Forge gradle
    checkPlugin('net.minecraftforge.gradle')
    // Mixin
    checkPlugin('org.spongepowered.mixin')
}

checkPlugin('com.github.johnrengelman.shadow')

apply plugin: 'java'
apply plugin: 'idea'

idea {
    module {
        downloadJavadoc = true
        downloadSources = true
    }
}

def java_language_version = JavaLanguageVersion.of(java_version)
sourceCompatibility = java_language_version
targetCompatibility = java_language_version
java.toolchain.languageVersion = java_language_version

group = getOrDefault('maven_group', "de.maxhenkel.${mod_id.replaceAll('_', '')}")
archivesBaseName = getOrDefault('archives_base_name', "${mod_id.replaceAll('_', '-')}-${mod_loader}")
version = mod_version

// Run configurations
// Fabric run configuration
if (is_fabric) {
    runClient.doFirst {
        args = ['--username', "${minecraft_user_name_prefix}${new Random().nextInt(1000)}"]
    }

    // Access widener
    def accesswidenerFile = file("src/main/resources/${mod_id}.accesswidener")
    if (enable_accesswideners && accesswidenerFile.exists()) {
        loom {
            accessWidenerPath = accesswidenerFile
        }
    }
}

// Neoforge run configuration
if (is_neoforge) {
    configurations {
        minecraftLibrary {}
        // implementation.extendsFrom minecraftLibrary
        minecraftLibrary.extendsFrom implementation
    }

    runs {
        configureEach {
            modSource project.sourceSets.main
            systemProperty 'forge.logging.console.level', 'debug'
            dependencies {
                runtime project.configurations.minecraftLibrary
            }
        }
        client {
            workingDirectory file('run')
            programArguments = ['--username', "${minecraft_user_name_prefix}${new Random().nextInt(1000)}"]
        }
        server {
            workingDirectory file('run/server')
            programArguments = ['--nogui']
        }
    }

    sourceSets.main.resources { srcDir 'src/generated/resources' }

    if (use_mixins) {
        mixin {
            config "${mod_id}.mixins.json"
        }
    }
}

// Forge run configuration
if (is_forge) {
    minecraft {
        mappings channel: 'official', version: minecraft_version
        copyIdeResources = true
        runs {
            configureEach {
                property 'forge.logging.console.level', 'debug'
            }
            client {
                workingDirectory file('run')
                args = ['--username', "${minecraft_user_name_prefix}${new Random().nextInt(1000)}"]
            }
            server {
                workingDirectory file('run/server')
                arg '--nogui'
            }
            data {
                workingDirectory file('run')
                args '--mod', mod_id, '--all', '--output', file('src/generated/resources/')
            }
        }
    }

    sourceSets.main.resources { srcDir 'src/generated/resources' }

    if (use_mixins) {
        mixin {
            add sourceSets.main, "${mod_id}.refmap.json"
        }
    }

    sourceSets.each {
        def dir = layout.buildDirectory.dir("sourcesSets/$it.name")
        it.output.resourcesDir = dir
        it.java.destinationDirectory = dir
    }
}

// Dependency management
repositories {
    maven { url = 'https://maven.maxhenkel.de/repository/public' }
    maven {
        url = 'https://api.modrinth.com/maven'
        content {
            includeGroup "maven.modrinth"
        }
    }
}

dependencies {
    if (is_fabric) {
        minecraft "com.mojang:minecraft:${minecraft_version}"
        mappings loom.officialMojangMappings()
        modImplementation "net.fabricmc:fabric-loader:${fabric_loader_version}"

        // Fabric API
        if (hasProperty('fabric_api_version')) {
            // TODO Throw error when API modules are present but no Fabric API version
            included_fabric_api_modules.forEach {
                include(modImplementation(fabricApi.module(it, fabric_api_version)))
            }
            if (import_fabric_api) {
                modImplementation "net.fabricmc.fabric-api:fabric-api:${fabric_api_version}"
            }
        }
    }

    if (is_neoforge) {
        implementation "net.neoforged:neoforge:${neoforge_version}"
    }

    if (is_forge) {
        minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"
        annotationProcessor "org.spongepowered:mixin:${mixin_annotation_processor_version}:processor"
    }

    included_projects.forEach({
        def hasNamedElements = project(it).getConfigurations().findByName('namedElements') != null
        def included_project = hasNamedElements ? project(path: it, configuration: 'namedElements') : project(it)
        if (is_neoforge || is_forge) {
            compileOnly(included_project) {
                transitive false
            }
        } else {
            implementation(included_project) {
                transitive false
            }
        }
        shadow(included_project) {
            transitive false
        }
    })

    implementation 'com.google.code.findbugs:jsr305:3.0.2'

    if (enable_configbuilder) {
        implementation "de.maxhenkel.configbuilder:configbuilder:${configbuilder_version}"
        shadow "de.maxhenkel.configbuilder:configbuilder:${configbuilder_version}"
        if (is_neoforge || is_forge) {
            minecraftLibrary "de.maxhenkel.configbuilder:configbuilder:${configbuilder_version}"
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    it.options.encoding = 'UTF-8'
    it.options.release = 17

    if (!is_neoforge) {
        included_projects.forEach({
            source(project(it).sourceSets.main.allSource)
        })
    }
}

if (is_neoforge) {
    tasks.withType(JavaCompile).matching(it -> !it.name.startsWith("neo")).configureEach {
        included_projects.forEach({
            source(project(it).sourceSets.main.allSource)
        })
    }
}

processResources {
    included_projects.forEach({
        from("${project(it).projectDir}/src/main/resources")
    })
}

java {
    withSourcesJar()
}

jar {
    from('LICENSE') {
        rename { "${it}_${archivesBaseName}" }
    }

    // Manifest attributes
    if (is_neoforge) {
        manifest {
            attributes(['Specification-Title'     : mod_display_name,
                        'Specification-Vendor'    : mod_authors.join(', '),
                        'Specification-Version'   : '1',
                        'Implementation-Title'    : mod_display_name,
                        'Implementation-Version'  : mod_version,
                        'Implementation-Vendor'   : mod_authors.join(', '),
                        'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),])
        }
    }

    if (is_forge) {
        manifest {
            attributes(['Specification-Title'     : mod_display_name,
                        'Specification-Vendor'    : mod_authors.join(', '),
                        'Specification-Version'   : '1',
                        'Implementation-Title'    : mod_display_name,
                        'Implementation-Version'  : mod_version,
                        'Implementation-Vendor'   : mod_authors.join(', '),
                        'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                        'MixinConnector'          : mixin_connector_path],)
        }
    }
}
jar.finalizedBy('shadowJar')

shadowJar {
    configurations = [project.configurations.shadow]
    if (is_fabric) {
        archiveClassifier = 'shadow-dev'
    }
    if (is_neoforge || is_forge) {
        archiveClassifier = ''
    }
    if (enable_configbuilder) {
        relocate 'de.maxhenkel.configbuilder', "de.maxhenkel.${mod_id}.configbuilder"
    }
}

if (is_fabric) {
    remapJar {
        dependsOn shadowJar
        inputFile = shadowJar.archiveFile.get()
    }
}

if (is_forge) {
    shadowJar.dependsOn('reobfJar')
    reobf {
        shadowJar {}
    }
}

// NeoForge clean fix
if (is_neoforge) {
    // https://github.com/neoforged/NeoGradle/issues/18#issuecomment-1858754401
    tasks.register('customClean', Delete) {
        doLast {
            def files = []
            fileTree("build")
                    .exclude('**/expanded.lock')
                    .visit { FileVisitDetails fvd ->
                        files << fvd.file
                    }
            files.reverse()
                    .each { f ->
                        def file = file(f)
                        if (!file.exists()) return;
                        if ((file.isDirectory() && file.list().size() == 0)
                                || !file.isDirectory())
                            delete f
                    }
        }
    }
    clean.dependsOn customClean
    clean.enabled = false
}

// CurseForge Upload
if (enable_curseforge_upload) {
    curseforge {
        apiKey = curseforge_api_key
        project {
            id = curseforge_upload_id
            changelogType = 'markdown'
            changelog = getChangelogFile()
            releaseType = upload_release_type
            addGameVersion curseforge_upload_minecraft_version
            if (is_fabric) {
                addGameVersion 'Fabric'
                if (add_quilt_supported_tag) {
                    addGameVersion 'Quilt'
                }
            }
            if (is_neoforge) {
                addGameVersion 'NeoForge'
            }
            if (is_forge) {
                addGameVersion 'Forge'
            }
            addGameVersion "Java ${java_version}"
            mainArtifact(getUploadArtefact()) { //TODO Check if this works
                //mainArtifact(file("${layout.buildDirectory.asFile.get()}/libs/${archivesBaseName}-${version}.jar")) {
                displayName = "[${mod_loader.toUpperCase()}][${minecraft_version}] ${mod_display_name} ${mod_version}"
                if (curseforge_upload_optional_dependencies) {
                    relations {
                        curseforge_upload_optional_dependencies.forEach({
                            optionalDependency it
                        })
                    }
                }
            }
            //TODO Check if it works without that on Fabric
            /*afterEvaluate {
                uploadTask.dependsOn(remapJar)
            }*/
        }
        options {
            forgeGradleIntegration = false
        }
    }
    tasks.curseforge.dependsOn(shadowJar)
}

// Modrinth Upload
if (enable_modrinth_upload) {
    tasks.modrinth.configure({
        group = 'upload'
    })
    tasks.modrinthSyncBody.configure({
        group = 'upload'
    })

    modrinth {
        token = modrinth_token
        projectId = modrinth_upload_id
        versionNumber = "${mod_loader}-${mod_version}"
        versionName = "[${mod_loader.toUpperCase()}][${minecraft_version}] ${mod_display_name} ${mod_version}"
        uploadFile = getUploadArtefact()
        versionType = upload_release_type.toUpperCase()
        changelog = getChangelogFile().text
        gameVersions = [minecraft_version]
        loaders = [mod_loader]
        if (is_fabric && add_quilt_supported_tag) {
            loaders.add('quilt')
        }
        dependencies {
            modrinth_upload_optional_dependencies.forEach({
                optional.project it
            })
        }
        syncBodyFrom = file("${rootDir}/readme.md").text
    }
    tasks.modrinth.dependsOn(shadowJar)
}

// Mod Update
if (enable_mod_update) {
    def changelog = getChangelogFile()
    modUpdate {
        apiKey = mod_update_api_key
        serverURL = 'https://update.maxhenkel.de/'
        modID = mod_id
        gameVersion = minecraft_version
        modLoader = mod_loader
        modVersion = mod_version
        changelogFile = changelog
        releaseType = upload_release_type
        tags = upload_recommended == 'true' ? ['recommended'] : []
    }
}

// Utility functions
/**
 * Checks if a property exists or falls back to a default value.
 *
 * @param propertyName the name of the property to check
 * @param defaultValue the default value if the property doesn't exists
 * @param mutator mutates the return value (Only applied if the property exists)
 * @return the property
 */
def <T> T getOrDefault(String propertyName, T defaultValue = null, Closure mutator = { it }) {
    if (!hasProperty(propertyName)) {
        return defaultValue
    }
    return mutator(getProperty(propertyName))
}

/**
 * Throws an exception if a property doesn't exist.
 *
 * @param propertyName the name of the property to check
 */
def checkProperty(String propertyName) {
    if (!hasProperty(propertyName)) {
        throw new RuntimeException("No property '${propertyName}' defined")
    }
}

def hasPlugin(String pluginName) {
    return getPluginManager().hasPlugin(pluginName)
}

def checkPlugin(String pluginName) {
    if (!hasPlugin(pluginName)) {
        throw new RuntimeException("Missing plugin '${pluginName}'")
    }
}

static def stringToStringList(String str) {
    return str.split(',').collect({ it.trim() })
}

def getChangelogFile() {
    def file = file('changelog.md').exists() ? file('changelog.md') : file("${rootDir}/changelog.md")
    if (file == null || !file.exists()) {
        throw new RuntimeException('Missing changelog')
    }
    return file
}

def getUploadArtefact() {
    return is_fabric ? remapJar : shadowJar
}
